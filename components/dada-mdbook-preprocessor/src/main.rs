use anyhow::{bail, Result};
use clap::{Arg, ArgMatches, Command};
use mdbook_preprocessor::book::{Book, BookItem, Chapter};
use mdbook_preprocessor::{Preprocessor, PreprocessorContext};
use regex::Regex;
use serde::Deserialize;
use std::collections::HashMap;
use std::io;
use std::path::Path;
use std::process;

pub fn make_app() -> Command {
    Command::new("dada-mdbook-preprocessor")
        .about("An mdbook preprocessor for processing Dada spec directives")
        .subcommand(
            Command::new("supports")
                .arg(Arg::new("renderer").required(true))
                .about("Check whether a renderer is supported by this preprocessor"),
        )
}

fn main() {
    let matches = make_app().get_matches();

    let preprocessor = DadaPreprocessor::new();

    if let Some(sub_args) = matches.subcommand_matches("supports") {
        handle_supports(&preprocessor, sub_args);
    } else if let Err(e) = handle_preprocessing(&preprocessor) {
        eprintln!("{e}");
        process::exit(1);
    }
}

fn handle_supports(pre: &dyn Preprocessor, sub_args: &ArgMatches) -> ! {
    let renderer = sub_args
        .get_one::<String>("renderer")
        .expect("Required argument");
    let supported = pre.supports_renderer(renderer).unwrap();

    if supported {
        process::exit(0);
    } else {
        process::exit(1);
    }
}

fn handle_preprocessing(pre: &dyn Preprocessor) -> Result<()> {
    let (ctx, book) = mdbook_preprocessor::parse_input(io::stdin())?;

    let book_version = Version::parse(&ctx.mdbook_version)?;
    let version_req = VersionReq::parse(mdbook_preprocessor::MDBOOK_VERSION)?;

    if !version_req.matches(&book_version) {
        eprintln!(
            "Warning: The {} plugin was built against version {} of mdbook, \
             but we're being called from version {}",
            pre.name(),
            mdbook_preprocessor::MDBOOK_VERSION,
            ctx.mdbook_version
        );
    }

    let processed_book = pre.run(&ctx, book)?;
    serde_json::to_writer(io::stdout(), &processed_book)?;

    Ok(())
}

use semver::{Version, VersionReq};

#[derive(Debug, Deserialize)]
struct RfcFrontMatter {
    status: String,
    #[serde(rename = "tracking-issue")]
    tracking_issue: Option<String>,
    #[serde(rename = "implemented-version")]
    implemented_version: Option<String>,
}

#[derive(Debug)]
struct RfcInfo {
    number: String,
    title: String,
    path: String,
    status: String,
    status_display: String,
    full_summary_markdown: String,
}

struct DadaPreprocessor;

impl DadaPreprocessor {
    pub fn new() -> DadaPreprocessor {
        DadaPreprocessor
    }
}

impl Preprocessor for DadaPreprocessor {
    fn name(&self) -> &str {
        "dada-mdbook-preprocessor"
    }

    fn run(&self, ctx: &PreprocessorContext, book: Book) -> Result<Book> {
        let mut book = book;
        // üí° Match MyST directive syntax: `:::{spec} paragraph.id [rfcN...]`
        let re = Regex::new(r"^:::\{spec\}").unwrap();

        // First pass: process spec directives
        book.for_each_mut(|item: &mut BookItem| {
            if let BookItem::Chapter(chapter) = item {
                // Check if this chapter has any spec directives
                let has_labels = chapter.content.lines().any(|line| re.is_match(line.trim()));

                // Process the content
                chapter.content = process_spec_directives(&chapter.content);

                // If this chapter has labels, inject CSS at the end
                if has_labels {
                    chapter.content.push('\n');
                    chapter.content.push_str(&get_inline_css());
                }
            }
        });

        // Second pass: populate RFC sections
        populate_rfc_sections(ctx, &mut book)?;

        // Third pass: inject CSS for any chapters with RFC tables
        book.for_each_mut(|item: &mut BookItem| {
            if let BookItem::Chapter(chapter) = item {
                // Check if this chapter has RFC tables (after RFC generation)
                let has_rfc_tables = chapter.content.contains("class=\"rfc-table\"");

                // Check if CSS is already injected
                let already_has_css = chapter
                    .content
                    .contains("/* Generated by dada-mdbook-preprocessor");

                // If this chapter has RFC tables and doesn't already have CSS, inject it
                if has_rfc_tables && !already_has_css {
                    chapter.content.push('\n');
                    chapter.content.push_str(&get_inline_css());
                }
            }
        });

        Ok(book)
    }

    fn supports_renderer(&self, renderer: &str) -> Result<bool> {
        Ok(renderer != "not-supported")
    }
}

/// Processes MyST `{spec}` directives into HTML with anchors and styling.
///
/// üí° Transforms directive blocks like:
/// ```markdown
/// :::{spec} syntax.foo rfc123
/// Content here.
/// :::
/// ```
/// Into styled HTML with anchor links and RFC badges.
fn process_spec_directives(content: &str) -> String {
    // Match the opening directive: `:::{spec} id [rfc-tags...]`
    let directive_start = Regex::new(r"^:::\{spec\}\s+(\S+)(.*)$").unwrap();
    let directive_end = Regex::new(r"^:::$").unwrap();

    let mut result = Vec::new();
    let mut in_directive = false;
    let mut current_id = String::new();
    let mut current_rfc_tags: Vec<String> = Vec::new();
    let mut directive_content: Vec<String> = Vec::new();

    for line in content.lines() {
        let trimmed = line.trim();

        if !in_directive {
            if let Some(captures) = directive_start.captures(trimmed) {
                // Start of a spec directive
                in_directive = true;
                current_id = captures[1].to_string();

                // Parse optional RFC tags from the rest of the line
                let rest = captures.get(2).map(|m| m.as_str()).unwrap_or("");
                current_rfc_tags = rest
                    .split_whitespace()
                    .filter(|s| !s.is_empty())
                    .map(|s| s.to_string())
                    .collect();

                directive_content.clear();
            } else {
                result.push(line.to_string());
            }
        } else if directive_end.is_match(trimmed) {
            // End of directive - generate HTML
            let rfc_badges = if current_rfc_tags.is_empty() {
                String::new()
            } else {
                let badges: Vec<String> = current_rfc_tags
                    .iter()
                    .map(|tag| {
                        if tag.starts_with('!') {
                            format!("<span class=\"spec-rfc-badge spec-rfc-deleted\">{tag}</span>")
                        } else {
                            format!("<span class=\"spec-rfc-badge\">{tag}</span>")
                        }
                    })
                    .collect();
                format!(" {}", badges.join(" "))
            };

            // Generate HTML wrapper
            result.push(format!(
                "<div class=\"spec-paragraph\" id=\"{current_id}\">"
            ));
            result.push(format!(
                "<div class=\"spec-label\"><a href=\"#{current_id}\" class=\"spec-label-link\">{current_id}</a>{rfc_badges}</div>"
            ));
            result.push("<div class=\"spec-content\">".to_string());
            result.push(String::new()); // Empty line for markdown processing
            for content_line in &directive_content {
                result.push(content_line.clone());
            }
            result.push(String::new()); // Empty line for markdown processing
            result.push("</div>".to_string());
            result.push("</div>".to_string());

            in_directive = false;
            current_id.clear();
            current_rfc_tags.clear();
        } else {
            // Inside directive - collect content
            directive_content.push(line.to_string());
        }
    }

    result.join("\n")
}

fn get_inline_css() -> String {
    r#"<style>
/* Generated by dada-mdbook-preprocessor - Styling for specification paragraphs */
.spec-paragraph {
    margin: 1rem 0;
    padding: 0.75rem 1rem;
    border-left: 3px solid #d0d7de;
    background-color: #f8f9fa;
    border-radius: 0 4px 4px 0;
}

.spec-label {
    margin-bottom: 0.5rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    flex-wrap: wrap;
}

.spec-label-link {
    font-size: 0.75rem;
    color: #666;
    text-decoration: none;
    font-family: 'SFMono-Regular', 'Monaco', 'Inconsolata', 'Fira Code', 'Source Code Pro', monospace;
    background-color: #fff;
    padding: 0.125rem 0.375rem;
    border-radius: 0.25rem;
    border: 1px solid #d0d7de;
}

.spec-label-link:hover {
    color: #0366d6;
    background-color: #f1f8ff;
    border-color: #c8e1ff;
    text-decoration: none;
}

.spec-content {
    margin: 0;
}

.spec-content > p:first-child {
    margin-top: 0;
}

.spec-content > p:last-child {
    margin-bottom: 0;
}

.spec-rfc-badge {
    font-size: 0.65rem;
    color: #fff;
    background-color: #0969da;
    padding: 0.1rem 0.3rem;
    border-radius: 0.25rem;
    font-family: 'SFMono-Regular', 'Monaco', 'Inconsolata', 'Fira Code', 'Source Code Pro', monospace;
}

.spec-rfc-badge.spec-rfc-deleted {
    background-color: #cf222e;
}

/* Dark theme support */
.navy .spec-paragraph {
    border-color: #30363d;
    background-color: #161b22;
}

.navy .spec-label-link {
    color: #c5c5c5;
    background-color: #21262d;
    border-color: #30363d;
}

.navy .spec-label-link:hover {
    color: #79b8ff;
    background-color: #1c2128;
    border-color: #30363d;
}

.navy .spec-rfc-badge {
    background-color: #58a6ff;
    color: #0d1117;
}

.navy .spec-rfc-badge.spec-rfc-deleted {
    background-color: #f85149;
}

/* RFC Table Styling - GitHub-inspired */
.rfc-table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 1.5rem;
    border: 1px solid #d0d7de;
    border-radius: 6px;
    overflow: hidden;
}

.rfc-header-row {
    background-color: #f6f8fa;
    border-bottom: 1px solid #d0d7de;
}

.rfc-header-row:hover {
    background-color: #f1f8ff;
}

.rfc-number {
    width: 60px;
    padding: 12px 16px;
    text-align: center;
    font-weight: 600;
    font-size: 14px;
    color: #656d76;
    background-color: inherit;
}

.rfc-details {
    display: flex;
    align-items: center;
    justify-content: center;
}

.rfc-details summary {
    cursor: pointer;
    list-style: none;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
}

.rfc-details summary::-webkit-details-marker {
    display: none;
}

.rfc-details summary::before {
    content: "‚ñ∂";
    font-size: 10px;
    margin-right: 6px;
    transition: transform 0.2s ease;
}

.rfc-details[open] summary::before {
    transform: rotate(90deg);
}

.rfc-title {
    padding: 12px 16px;
    font-weight: 600;
    font-size: 14px;
}

.rfc-title a {
    color: #0969da;
    text-decoration: none;
}

.rfc-title a:hover {
    text-decoration: underline;
}

.rfc-summary-row {
    display: none;
}

.rfc-details[open] ~ .rfc-header-row ~ .rfc-summary-row,
.rfc-table:has(.rfc-details[open]) .rfc-summary-row {
    display: table-row;
}

.rfc-summary-content {
    padding: 16px;
    font-size: 13px;
    color: #656d76;
    font-weight: normal;
    border-top: 1px solid #d0d7de;
    background-color: #f8f9fa;
}

.rfc-status {
    width: 120px;
    padding: 12px 16px;
    text-align: center;
    vertical-align: middle;
}

/* Dark theme support for RFC tables */
.navy .rfc-table {
    border-color: #30363d;
}

.navy .rfc-header-row {
    background-color: #21262d;
    border-color: #30363d;
}

.navy .rfc-header-row:hover {
    background-color: #1c2128;
}

.navy .rfc-number {
    color: #7d8590;
}

.navy .rfc-title a {
    color: #58a6ff;
}

.navy .rfc-summary-content {
    border-color: #30363d;
    color: #7d8590;
    background-color: #161b22;
}
</style>"#.to_string()
}

fn populate_rfc_sections(ctx: &PreprocessorContext, book: &mut Book) -> Result<()> {
    // Find the position of the "All RFCs" chapter
    let mut rfc_chapter_index = None;

    for (index, item) in book.items.iter().enumerate() {
        if let BookItem::Chapter(chapter) = item {
            // Check if this is the All RFCs chapter
            if chapter.name.trim() == "All RFCs" {
                rfc_chapter_index = Some(index);
                break;
            }
        }
    }

    // If we found the All RFCs chapter, populate it
    if let Some(index) = rfc_chapter_index {
        // Get a mutable reference to the chapter
        if let Some(BookItem::Chapter(chapter)) = book.items.get_mut(index) {
            populate_all_rfcs_section(ctx, chapter)?;
        }
    }

    Ok(())
}

fn populate_all_rfcs_section(ctx: &PreprocessorContext, chapter: &mut Chapter) -> Result<()> {
    let src_dir = ctx.config.book.src.clone();

    // Find all RFC directories
    let mut rfc_dirs = Vec::new();
    if let Ok(entries) = std::fs::read_dir(&src_dir) {
        for entry in entries {
            let entry = entry?;
            let path = entry.path();
            if path.is_dir() {
                if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
                    // Match directories like 0001-feature-name
                    if name.len() > 4
                        && name[..4].chars().all(|c| c.is_ascii_digit())
                        && name.chars().nth(4) == Some('-')
                    {
                        rfc_dirs.push((name.to_string(), path));
                    }
                }
            }
        }
    }

    // Sort by RFC number
    rfc_dirs.sort_by(|a, b| a.0.cmp(&b.0));

    // Process each RFC directory to extract info
    let mut rfcs_by_status: HashMap<String, Vec<RfcInfo>> = HashMap::new();

    for (dir_name, dir_path) in rfc_dirs {
        if let Ok(rfc_info) = extract_rfc_info(&dir_path, &dir_name) {
            rfcs_by_status
                .entry(rfc_info.status.clone())
                .or_default()
                .push(rfc_info);
        }
    }

    // Generate HTML content for the all.md page
    let html_content = generate_all_rfcs_html(&rfcs_by_status);

    // Replace the chapter content
    chapter.content = format!("# All RFCs\n\n{html_content}");

    // Process each RFC directory for sub-chapters (keep existing functionality)
    let src_dir = ctx.config.book.src.clone();
    let mut rfc_dirs = Vec::new();
    if let Ok(entries) = std::fs::read_dir(&src_dir) {
        for entry in entries {
            let entry = entry?;
            let path = entry.path();
            if path.is_dir() {
                if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
                    if name.len() > 4
                        && name[..4].chars().all(|c| c.is_ascii_digit())
                        && name.chars().nth(4) == Some('-')
                    {
                        rfc_dirs.push((name.to_string(), path));
                    }
                }
            }
        }
    }
    rfc_dirs.sort_by(|a, b| a.0.cmp(&b.0));

    for ((dir_name, dir_path), index) in rfc_dirs.iter().zip(0..) {
        if let Ok(rfc_chapter) = create_rfc_chapter(&src_dir, dir_name, dir_path, chapter, index) {
            chapter.sub_items.push(BookItem::Chapter(rfc_chapter));
        }
    }

    Ok(())
}

fn create_rfc_chapter(
    src_dir: &Path,
    dir_name: &str,
    dir_path: &Path,
    all_rfcs_chapter: &Chapter,
    rfc_index: u32,
) -> Result<Chapter> {
    // Read README.md to get the title
    let readme_path = dir_path.join("README.md");
    let readme_content = std::fs::read_to_string(&readme_path)?;

    // Extract title from first # line
    let title = readme_content
        .lines()
        .find(|line| line.starts_with("# "))
        .map(|line| line[2..].trim())
        .unwrap_or(dir_name)
        .to_string();

    // Create relative path for mdbook
    let relative_path = readme_path.strip_prefix(src_dir)?.to_path_buf();

    // Create proper parent names for nested structure
    let mut rfc_parent_names = all_rfcs_chapter.parent_names.clone();
    rfc_parent_names.push(all_rfcs_chapter.name.clone());

    // Get the section number of the parent and convert it to the section number of the new child
    let Some(mut section_number) = all_rfcs_chapter.number.clone() else {
        bail!("All RFCs chapter has no number")
    };
    section_number.push(rfc_index);

    let mut rfc_chapter = Chapter::new(
        &title,
        readme_content,
        relative_path,
        rfc_parent_names.clone(),
    );
    rfc_chapter.number = Some(section_number.clone());

    // Find all other .md files in the directory
    if let Ok(entries) = std::fs::read_dir(dir_path) {
        let mut sub_files = Vec::new();

        for entry in entries {
            let entry = entry?;
            let path = entry.path();

            if path.is_file() && path.extension().and_then(|s| s.to_str()) == Some("md") {
                let file_name = path.file_name().and_then(|n| n.to_str()).unwrap_or("");
                if file_name != "README.md" {
                    sub_files.push(path);
                }
            }
        }

        // Sort sub-files for consistent ordering
        sub_files.sort();

        // Create sub-chapters for each .md file
        let mut sub_parent_names = rfc_parent_names.clone();
        sub_parent_names.push(title.clone());

        for (sub_path, sub_index) in sub_files.iter().zip(0..) {
            if let Ok(sub_content) = std::fs::read_to_string(sub_path) {
                // Extract title from first # line
                let sub_title = sub_content
                    .lines()
                    .find(|line| line.starts_with("# "))
                    .map(|line| line[2..].trim())
                    .unwrap_or_else(|| {
                        sub_path
                            .file_stem()
                            .and_then(|s| s.to_str())
                            .unwrap_or("Untitled")
                    })
                    .to_string();

                let sub_relative_path = sub_path.strip_prefix(src_dir)?.to_path_buf();

                let mut sub_chapter = Chapter::new(
                    &sub_title,
                    sub_content,
                    sub_relative_path,
                    sub_parent_names.clone(),
                );

                // assign the section number for this subchapter
                section_number.push(sub_index);
                sub_chapter.number = Some(section_number.clone());
                section_number.pop().unwrap();

                rfc_chapter.sub_items.push(BookItem::Chapter(sub_chapter));
            }
        }
    }

    Ok(rfc_chapter)
}

fn extract_rfc_info(dir_path: &Path, dir_name: &str) -> Result<RfcInfo> {
    // Read README.md to get the title and content
    let readme_path = dir_path.join("README.md");
    let readme_content = std::fs::read_to_string(&readme_path)?;

    // Parse front matter and content
    let (front_matter, content) = parse_front_matter(&readme_content)?;

    // Extract RFC number from directory name (e.g., "0001-string-literals" -> "0001")
    let number = dir_name[..4].to_string();

    // Extract title from first # line
    let title = content
        .lines()
        .find(|line| line.starts_with("# "))
        .map(|line| line[2..].trim())
        .unwrap_or(dir_name)
        .to_string();

    // Extract summary section
    let summary_section = extract_section(&content, "## Summary");

    // Generate status display
    let status_display = format_status(
        &front_matter.status,
        &front_matter.tracking_issue,
        &front_matter.implemented_version,
    );

    Ok(RfcInfo {
        number,
        title,
        path: dir_name.to_string(),
        status: front_matter.status,
        status_display,
        full_summary_markdown: summary_section,
    })
}

fn parse_front_matter(content: &str) -> Result<(RfcFrontMatter, String)> {
    let lines: Vec<&str> = content.lines().collect();

    // Check if content starts with front matter
    if lines.is_empty() || !lines[0].trim().starts_with("---") {
        // No front matter, use defaults
        let default_front_matter = RfcFrontMatter {
            status: "draft".to_string(),
            tracking_issue: None,
            implemented_version: None,
        };
        return Ok((default_front_matter, content.to_string()));
    }

    // Find the end of front matter
    let mut end_index = None;
    for (i, line) in lines.iter().enumerate().skip(1) {
        if line.trim() == "---" {
            end_index = Some(i);
            break;
        }
    }

    let end_index = end_index.ok_or_else(|| anyhow::anyhow!("Unclosed front matter"))?;

    // Extract and parse front matter
    let front_matter_text = lines[1..end_index].join("\n");
    let front_matter: RfcFrontMatter =
        serde_yaml::from_str(&front_matter_text).unwrap_or_else(|_| RfcFrontMatter {
            status: "draft".to_string(),
            tracking_issue: None,
            implemented_version: None,
        });

    // Extract content after front matter
    let content_lines = if end_index + 1 < lines.len() {
        &lines[end_index + 1..]
    } else {
        &[]
    };
    let content = content_lines.join("\n");

    Ok((front_matter, content))
}

fn extract_section(content: &str, heading: &str) -> String {
    let lines: Vec<&str> = content.lines().collect();
    let mut in_section = false;
    let mut section_lines = Vec::new();

    for line in lines {
        if line.starts_with("## ") {
            if line.trim() == heading {
                in_section = true;
                continue; // Skip the heading itself
            } else if in_section {
                break; // Hit next section, stop
            }
        }

        if in_section {
            section_lines.push(line);
        }
    }

    section_lines.join("\n").trim().to_string()
}

fn format_status(
    status: &str,
    tracking_issue: &Option<String>,
    implemented_version: &Option<String>,
) -> String {
    let (color, label) = match status {
        "active" => ("blue", "Active"),
        "accepted" => ("green", "Accepted"),
        "implemented" => ("brightgreen", "Implemented"),
        "draft" => ("lightgrey", "Draft"),
        "rejected" => ("red", "Rejected"),
        "withdrawn" => ("red", "Withdrawn"),
        _ => ("lightgrey", "Unknown"),
    };

    let mut badge_text = label.to_string();

    // Add version info if implemented
    if let Some(version) = implemented_version {
        badge_text = format!("{badge_text} v{version}");
    }

    // Add tracking issue if present
    if let Some(issue) = tracking_issue {
        if issue.chars().all(|c| c.is_ascii_digit()) {
            badge_text = format!("{badge_text} %23{issue}"); // %23 is URL-encoded #
        } else if let Some(issue_num) = issue.strip_prefix('#') {
            if issue_num.chars().all(|c| c.is_ascii_digit()) {
                badge_text = format!("{badge_text} %23{issue_num}");
            }
        }
    }

    // URL encode spaces and other characters
    let encoded_text = badge_text.replace(" ", "%20");

    let badge_url = format!("https://img.shields.io/badge/Status-{encoded_text}-{color}");

    // Generate HTML img tag instead of markdown since we're in an HTML table
    if let Some(issue) = tracking_issue {
        if issue.chars().all(|c| c.is_ascii_digit())
            || (issue.starts_with('#') && issue[1..].chars().all(|c| c.is_ascii_digit()))
        {
            let issue_num = issue.strip_prefix('#').unwrap_or(issue);
            let github_url = format!("https://github.com/dada-lang/dada/issues/{issue_num}");
            format!("<a href=\"{github_url}\"><img src=\"{badge_url}\" alt=\"RFC Status\" /></a>")
        } else {
            format!("<img src=\"{badge_url}\" alt=\"RFC Status\" />")
        }
    } else {
        format!("<img src=\"{badge_url}\" alt=\"RFC Status\" />")
    }
}

fn generate_all_rfcs_html(rfcs_by_status: &HashMap<String, Vec<RfcInfo>>) -> String {
    let mut content = String::new();

    content.push_str("This page provides an overview of all RFCs (Request for Comments) in the Dada language development process.\n\n");

    // Define status order for display
    let status_headers = [
        (
            "active",
            "Active RFCs",
            "RFCs currently under discussion and development.",
        ),
        (
            "accepted",
            "Accepted RFCs",
            "RFCs that have been accepted but not yet implemented.",
        ),
        (
            "implemented",
            "Implemented RFCs",
            "RFCs that have been fully implemented and are part of the language.",
        ),
        (
            "draft",
            "Draft RFCs",
            "RFCs that are still being written or refined.",
        ),
        (
            "rejected",
            "Rejected/Withdrawn RFCs",
            "RFCs that were not accepted or were withdrawn.",
        ),
    ];

    for (status, header, description) in status_headers {
        if let Some(rfcs) = rfcs_by_status.get(status) {
            if !rfcs.is_empty() {
                content.push_str(&format!("## {header}\n\n"));
                content.push_str(&format!("{description}\n\n"));
                content.push_str(&generate_rfc_table_html(rfcs));
                content.push('\n');
            } else {
                // Show empty sections for non-draft/rejected statuses
                if status != "rejected" {
                    content.push_str(&format!("## {header}\n\n"));
                    content.push_str(&format!("{description}\n\n"));
                    content.push_str("*(None yet)*\n");
                    content.push('\n');
                }
            }
        } else {
            // Show empty sections for non-draft/rejected statuses
            if status != "rejected" {
                content.push_str(&format!("## {header}\n\n"));
                content.push_str(&format!("{description}\n\n"));
                content.push_str("*(None yet)*\n");
                content.push('\n');
            }
        }
    }

    content
}

fn generate_rfc_table_html(rfcs: &[RfcInfo]) -> String {
    let mut html = String::new();

    for rfc in rfcs {
        let rfc_number = rfc.number.parse::<u32>().unwrap_or(0);
        // ‚ö†Ô∏è IMPORTANT: The blank lines around {} in rfc-summary-content are REQUIRED!
        // They allow mdbook's markdown processor to parse markdown inside HTML blocks.
        // Without these newlines, content like `code` and **bold** won't be rendered.
        html.push_str(&format!(
            r#"<table class="rfc-table">
<tr class="rfc-header-row">
<td class="rfc-number">
<details class="rfc-details">
<summary>{}</summary>
</details>
</td>
<td class="rfc-title"><a href="./{}/README.md">{}</a></td>
<td class="rfc-status">{}</td>
</tr>
<tr class="rfc-summary-row">
<td colspan="3" class="rfc-summary-content">

{}

</td>
</tr>
</table>

"#,
            rfc_number,
            rfc.path,
            rfc.title,
            rfc.status_display,
            rfc.full_summary_markdown.trim()
        ));
    }

    html
}
